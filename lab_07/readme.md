# Лр 7 Ассемблерные вставки
А это уже интересная лаба, нужно было две функции: одна для strlen с помощью ассемблерной вставки, а другая strcpy в отдельном модуле на ассемблере. Ничего сложного, но достаточно интересно. +Ко всему этому нужно реализовать под 32-битную и 64-битную архитектуру (просто поменять названия регистров)

```cpp
extern "C" void my_strcpy(char *dst, const char *src, int len);

size_t my_strlen(const char *string)
{
    size_t res = 0;
    __asm__ volatile(
        "mov al, 0\n"               // Ищем нулевой байт
        "mov rcx, -1\n"             // Максимальное количество итераций
        "mov rdi, %1\n"             // Загружаем указатель на строку
        "cld\n"                     // Направление - вперед
        "repne scasb\n"             // Ищем нулевой байт
        "sub rdi, %1\n"             // Вычисляем длину
        "mov %0, rdi\n"            // Переносим результат
        "dec %0\n"                 // Корректируем длину
        
        : "=r"(res)                 // Выходной параметр
        : "r"(string)               // Входной параметр
        : "rax", "rcx", "rdi", "cc" // Разрушаемые регистры
    );

    return res;
}
```

